### recycleView 加载大数据 如何优化
一分页加载，二使用ViewHolder进行优化

### SharedPreferences 的四种加载模式的异同
四种模式
1. 私有模式context.MODE_PRIVATE的值为0
只能被创建这个文件的当前那应用访问
若文件不存在会创建文件，若创建的文件已存在会覆盖掉原来的文件

2. 追加模式 Context.MODE_APPEND 值为32768
只能被创建这个文件的当前应用访问
若文件不存在会创建文件，若文件存在则在文件的末尾进行追加内容

3. 可读模式Context.MODE_WORLD_READABLE的值是1
创建出来的文件可以被其他应用所读取

4. 可写模式Context.MODE_WORLD_WRITEABLE的值是2
允许其他应用对其进行写入

### java中的死锁
产生死锁的必要条件
1. 互斥条件：就是一个资源同时只能有一个进行占有，不能有两个或是两个以上的占有
2. 不可抢占条件：
### java中的锁
互斥锁/读写锁

独享所/共享锁

乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。

悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
### sync 同步方法和同步对象有什么区别
synchronized在方法上，所有这个类的加了synchronized的方法，在执行时会获得一个该类的唯一同步锁，当这个锁被占用时，其他的加了synchronized的方法就必须等待

synchronized 加在对象上的话，就是以这个对象为锁，其他也以这个对象为锁的代码段，在这个锁被占用时就必须等待

### 抽象类，接口区别

接口是对对象的抽象，抽象类是对根源的抽象

1. 抽象类和接口都不能直接实例化，抽象类变量必须指向所有抽象方法的子类，接口变量必须指向实现所有接口方法的类对象
2. 抽象类只能被继承，接口只能被实现
3. 接口中方法只能声明，抽象类种方法可以声明可以实现
4. 抽象类中的抽象方法必须全部由子类实现，若没有全部实现则该类为抽象类，同样一个实现接口的类没有完全实现接口方法，那么该类也只能是抽象类
5. 抽象方法只能被申明
6. 如果一个类中有抽象方法那么该类一定是抽象类
7. 接口可继承接口，并可继承多个接口，但类只能单继承



### 重载，重写

重载：多个同名函数同时存在，具有不同的参数个数/类型 。重载是一个类中多态性的一种表现

调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法，这就就是多态性

重写：参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载；
返回类型必须与被重写的方法的分会类型相同

### java 反射机制

### java classLoad 加载机制


### 事件分发机制如何走到dispatchEventTouch方法中去的
