### recycleView 加载大数据 如何优化
一分页加载，二使用ViewHolder进行优化

### SharedPreferences 的四种加载模式的异同
四种模式
1. 私有模式context.MODE_PRIVATE的值为0
只能被创建这个文件的当前那应用访问
若文件不存在会创建文件，若创建的文件已存在会覆盖掉原来的文件

2. 追加模式 Context.MODE_APPEND 值为32768
只能被创建这个文件的当前应用访问
若文件不存在会创建文件，若文件存在则在文件的末尾进行追加内容

3. 可读模式Context.MODE_WORLD_READABLE的值是1
创建出来的文件可以被其他应用所读取

4. 可写模式Context.MODE_WORLD_WRITEABLE的值是2
允许其他应用对其进行写入

### java中的死锁
产生死锁的必要条件
1. 互斥条件：就是一个资源同时只能有一个进行占有，不能有两个或是两个以上的占有
2. 不可抢占条件：
### java中的锁
互斥锁/读写锁

独享所/共享锁

乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。
在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。
乐观的认为，不加锁的并发操作是没有事情的。

悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。
因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
### sync 同步方法和同步对象有什么区别
synchronized在方法上，所有这个类的加了synchronized的方法，
在执行时会获得一个该类的唯一同步锁
，当这个锁被占用时，其他的加了synchronized的方法就必须等待

synchronized 加在对象上的话，就是以这个对象为锁，其他也以这个对象为锁的代码段，
在这个锁被占用时就必须等待

### 抽象类，接口区别

接口是对行为的抽象，抽象类是对根源的抽象

1. 抽象类和接口都不能直接实例化，抽象类变量必须指向所有抽象方法的子类，
   接口变量必须指向实现所有接口方法的类对象
2. 抽象类只能被继承，接口只能被实现
3. 接口中方法只能声明，抽象类种方法可以声明可以实现
4. 抽象类中的抽象方法必须全部由子类实现，若没有全部实现则该类为抽象类， 
   同样一个实现接口的类没有完全实现接口方法，那么该类也只能是抽象类
5. 抽象方法只能被申明
6. 如果一个类中有抽象方法那么该类一定是抽象类
7. 接口可继承接口，并可继承多个接口，但类只能单继承



### 重载，重写

重载：多个同名函数同时存在，具有不同的参数个数/类型 。重载是一个类中多态性的一种表现

调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法，这就就是多态性

重写：参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载；
返回类型必须与被重写的方法的分会类型相同


### java 反射机制
Java反射机制是指在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；
对于任意一个对象，都能够调用它的任意一个方法和属性；
这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
用一句话总结就是反射可以实现在运行时可以知道任意一个类的属性和方法。

### java classLoad 加载机制


### 事件分发机制如何走到dispatchEventTouch方法中去的

### 图片 四种压缩几种色彩详解
枚举变量
```
public static final Bitmap.Config ALPHA_8
public static final Bitmap.Config ARGB_4444
public static final Bitmap.Config ARGB_8888
public static final Bitmap.Config RGB_565

```
ARGB 指的是一种色彩模式，里面A代表Alpha，R表示red，G表示Green，B表示Blue，三原色，每个原色都存储这表示颜色的信息值

ALPHA_8  ：表示Alpha由8位组成
ARGB_4444:表示由4个4位组成即16位
ARGB_8888:表示由4个8位组成即32位
RGB_565  :表示R为5位，G为6位，B为5位共16位

ALPHA_8代表8位Alpha位图
ARGB_4444代表16位的ARGB位图
ARGB_8888代表32位的ARGB位图
RGB_565代表8位RGB位图

位图位数越高代表其可以存储的颜色信息就越多，当然图像也就越逼真。


### java的静态代理和动态代理
> 静态代理是在编译时就将接口、实现类、代理类全部手动完成，
> 动态代理可以在程序运行期间根据需要动态的创建代理类及其实例，来完成具体的功能

其实直接调用就可以完成功能为什么还要加个代理呢？
原因：采用代理模式可以有效的将具体的实现与调用方法解耦，
通过面向接口进行编码完全将具体的实现隐藏在内部。


