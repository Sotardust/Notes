### 性能优化
一、内存优化
1、尽量在使用service时才让其处于运行状态，尽量使用IntentService能节省系统资源
   （IntentService在内部都是用过线程和Handler来实现的，当有新的Intent到来时，会创建线程
   并处理这个Intent处理完之后自动销毁自身）

2、内存紧张时释放资源（例如UI隐藏时释放资源）

3、避免Bitmap的浪费，应尽量去适配屏幕设备，尽量使用成熟的图片框架。比如Picasso，fresco，glide等

4、使用优化的容器 例如sparseArray

5、避免内存泄漏（本应被回收的对象未被回收）一旦App的内部短时间内快速增长或者GC非常频繁的时候
   就应该考虑是否是内存泄漏导致的

二、布局优化
    1、使用include标签 复用相同布局
    2、尽量使用Relativelayout 减少视图层级

什么情况下会导致内存泄漏：
     1、资源释放问题：
            长期保持某些资源，如content，cursor，IO流的引用资源得不到释放造成内存泄漏
     2、对象内存过大问题：
            保存了多个耗用内存过大的对象（如Bitmap，xml文件）造成内存超出限制
     3、static关键字的使用：
            使用static修饰的变量生命周期比较长
     4、线程导致内存溢出：
             线程产生内存泄漏的主要原因在于线程生命周期的不可控

避免OOM的常见方法：
1、App资源中尽量少使用大图 使用bitmap时要注意按照比例缩小图片并注意bitmap回收

2、结合生命周期去释放资源

3、I/O流，数据库游标，使用完成后应及时释放掉

4、listview中使用viewHolder缓存convertview

5、页面切换尽量去传递（复用一些对象）



### 内存泄漏和内存溢出区别

**内存泄露**（memory leak） 原理是，使用过的内存空间没有被及时释放，长时间占用内存，最终导致内存空间不足，而出现内存溢出。

**内存溢出** （out of memory）是指你的应用的内存已经不能满足正常使用了，堆栈已经达到系统设置的最大值，进而导致崩溃。

 内存溢出就是内存越界。内存越界有一种很常见的情况是调用栈溢出（即stackoverflow），虽然这种情况可以看成是栈内存不足的一种体现。但内存溢出并不一定跟内存分配有什么关系，因为还有一种情况是缓冲区溢出


**内存溢出的原因：**
1、内存泄漏导致
由于长期保持某些资源（如Context）引用，垃圾回收器就无法回收它，导致该对象占用的内存就无法被使用，这就造成了内存泄漏。

2、占用内存较多的对象
保存了多个耗用内存过大的对象（如Bitmap） 或加载单个超大的图片，造成内存超出限制


**内存泄露的原因：**
1、资源对象没关闭  如cursor，file等资源
2、使用Adapter时，没有使用系统缓存的convertView
3、没有及时调用recycle()释放不再使用的bitmap
4、使用application的content来替代Activity相关的context 不要让生命周期长于Activity的对象持有到Activity的引用
5、广播注册没有取消造成内存泄漏
6、Handler应该申明为静态对象，并在其内部类中保存一个对外部类的弱引用

**二者联系 内存泄漏最终会导致内存溢出**

### LeakCanary捕获常见内存泄漏以及解决办法

**1.错误的使用单例模式造成的内存泄漏**
要保证Context和Application的生命周期一样，比如调用context.getApplicationContext()方法

**2.Handler造成的内存泄漏**
匿名内部类持有外部类对象引用

**3.线程造成的内存泄漏**
在处理一个比较耗时的操作时，该操作未结束时该Activity就退出了，但此时AsyncTask 依然持有对该Activity的引用，就会导致该Activity无法释放回收从而引起内存泄漏
解决办法：在使用AsyncTask时，在Activity销毁时也取消相应的任务AsyncTask.cancel()方法，避免任务在后台执行浪费资源，进而避免内存泄漏

**4.非静态内部类创建静态实例造成的内存泄漏**
内部类会持有外部类的引用，而内部类实例又是static静态变量其生命周期与Application生命周期一样
解决方法：把内部类改成静态内部类

**5.由WebView引起的内存泄漏**
[连接地址](https://www.cnblogs.com/whoislcj/p/6001422.html)

**6.资源未关闭造成的内存泄漏**
对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏


### JVM如何判定一个对象是垃圾对象？

该问题也即垃圾对象搜索算法，JVM采用图论的可达遍历算法来判定一个对象是否是垃圾对象， 如果对象A是可达的，则认为该对象是被引用的，GC不会回收；如果对象A或者块B（多个对象引用组成的对象块）是不可达的，那么该对象或者块则判定是不可达的垃圾对象，GC会回收。GC root 根搜索算法
[](https://upload-images.jianshu.io/upload_images/6668992-5540a3037c4ee84c.jpg?imageMogr2/auto-orient/)


### java 类种类
1. 内部类  内部类可以拥有private、protected访问权限以及包访问权限。
2. 局部内部类， 局部累不累是定义在一个方法或者一个作用域里面的类。局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。
3. 匿名内部类 例如设置点击事件（监听器）
4. 静态内部类 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。  
静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，
