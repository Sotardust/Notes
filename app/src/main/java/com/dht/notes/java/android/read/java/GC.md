### 垃圾收集算法
    1、标记-清除算法
        不足：
            1）标记-清除效率不高
            2）标记-清除之后产生大量不连续的空间碎片基于这样的不足 有了标记-整理算法
        
    2、标记-整理算法
        相比标记-清楚算法，不同的是整理过程。将存活对象移动到一端然后清除可回收对象，
        这样做的好处就是产生了连续的空间
    3、复制算法
        它将内存分为大小相等的2块，每次只是使用其中一块。当一块内存用完之后，
        就将存活的对象复制到另外一块内存区域并将本块内存清理。
        这样做的大大降低了内存空间使用率。我们的HotSpot的年轻代就是使用复制算法，只不过它的比例不是1：1，而是8：1。
    4、分代收集算法
     基于上面的几种收集算法，当前商业虚拟机基本采用的都是分代收集。结合了复制和标记-整理的优势。
  **  一般做法是将Java堆分为新生代和老年代。由于新生代会不断产生新生对象，
    因此采用了复制算法；而年老代的对象存活率较高，因此采用了标记-整理算法。**
    在新生代中，我们可以看到新生代=Eden+S0+S1；他们设计的默认比例是8：1：1
    ；这个参数是可以通过虚拟机参数进行调整的。
    
### 垃圾收集器
    1、Serial GC 
        区别Serial和Serial Old 的区别就是一个运行在新生代两一个是运行在老年代，
        是一个单线程模式的垃圾收集器，这里不仅仅是说该收集器是使用单线程或者一个cpu去
        完成垃圾收集，更重要的是他在进行垃圾收集的时候必须暂停用户线程，直到收集完成，
        也就是Stop the World
        ParNew收集器其实是Serial收集器的多线程版本。它也是运行在新生代中                      
    
    2、Parallel GC
        Parallel Scavenge也是一个新生代，多线程收集器。
        Parallel Scavenge收集器的特点是它关注一个可控的吞吐量。
        吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）；
        Parallel Old收集器，顾名思义是Parallel Scavenge收集器的老年代版本。
    
    3、CMS GC
        CMS(Concurrent Mark Sweep) 是一款基于并发使用标记清除算法的垃圾收集器
        它是一款以获取最短回收停顿时间为目标的收集器
    实现过程：
        应用程序线程->初始标记->并发标记->重新标记->并发清理->并发重置
        执行步骤：
            1、初始标记：仅仅标记GC Roots能直接关联到的对象，时间很短，阻塞用户线程
            2、并发标记：标记可回收对象，和用户线程并行
            3、重新标记：标记在并发阶段因用户线程继续运行产生的可回收对象，修正并发标记
            此时是阻塞用户线程
            4、并发清理：使用标记-清除算法那垃圾进行清理
            
            该算法存在3个缺点：
            1、对CPU资源敏感。一般并发执行的程序对CPU数量都是比较敏感的
            2、无法处理浮动垃圾。并发清理阶段用户线程还在执行，这时产生的垃圾无法清理
            3、由于标记-清除算法产生大量的空间碎片
    
    4、G1 GC
        G1 Garbage_First是当今收集器技术发展的最前沿成果之一，它是一款面向服务端的垃圾收集器
        
    实现思路：
        将整个java堆划分为多个大小相等的独立区域(Region),G1跟踪各个Region里面的垃圾堆积和价值大小，
        在后台维护一个优先列表，每次进行优先回收。那么Region不是孤立的。那么如何避免全堆扫描呢？
        G1使用Remembered Set。每一个Region对应一个Remembered Set，
        在虚拟机对Reference类型的数据进行写操作的时候，
        会检查Reference引用的对象是否处于不同的Region中，如是则记录到Remembered Set中。
        
    执行步骤：
        初始标记：标记GC Roots能直接关联到的对象，耗时短
        并发标记：找出存活的对象，耗时长
        最终标记：修正并发标记
        筛选回收：根据用户所期望的GC停顿时间来制定回收计划
        
        [link](https://zhuanlan.zhihu.com/p/25539690)