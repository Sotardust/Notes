### Android怎么加速启动Activity

+ 耗时操作优化  
    在主线程中尽量避免耗时操作，并对已有耗时操作进行优化  
* 布局优化  
    多余控件：用不到的控件和层级只会浪费界面的渲染时间  
    使用 `include`，`merge`,`ViewStub`
* 视图加载优化  
    最常见的就是我们的Fragment的懒加载，只有显示时才去加载  
    
Google给出的启动加速的方向：  
1. 利用提前展示出来的Window，快速展示出来一个界面，给用户快速反馈的体验；  
2. 避免在启动时做密集沉重的初始化（Heavy app initialization）；  
3. 定位问题：避免I/O操作、反序列化、网络操作、布局嵌套等。
    
### 如何防止内存泄漏？

### Android中弱引用与软引用的应用场景。
1. SoftReference：软引用–>当虚拟机内存不足时，将会回收它指向的对象；需要获取对象时，可以调用get方法。
2. WeakReference：弱引用–>随时可能会被垃圾回收器回收，不一定要等到虚拟机内存不足时才强制回收。要获取对象时，同样可以调用get方法。
3. WeakReference一般用来防止内存泄漏，要保证内存被虚拟机回收，SoftReference多用作来实现缓存机制(cache)。
4. 如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存，比如在图片加载框架中，通过弱引用来实现内存缓存。
5. 只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 Handler 弱引用，防止内存泄漏。
### Bitmap的四种属性，如何加载大图（inJustDecodeBounds）。

### invalidate(),requestLayout(),layout() 之间的区别
1. requestLayout(): 控件会重新执行onMeasure(),onLayout(),不会执行onDraw()方法
2. invalidate(): 是自定义的时候重新执行onDraw()方法
3. layout()：对控件进行重新定位执行onLayout()这个方法

### Android IPC:Binder原理。