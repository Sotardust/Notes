#### java虚拟机运行时数据区域

##### 程序计数器
 程序计数器（`Program Counter Register`）：是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器，此内存区域是唯一一个在Java虚拟机
规范中没有规定任何`OutOfMemoryError`情况的区域 （线程私有）
##### Java虚拟机栈
 Java虚拟机栈 与程序计数器一样，java虚拟机栈（`Java Virtual Machine Stacks`）也是线程私有，他的生命周期与线程相同。
虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、
动态链接、方法出口的信息。
每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
局部变量表 存放了各种基本数据类型，以及对象引用（reference类型，它不等同与对象本身，可能是一个指向对象其实地址的引用指针）类型
，也可能是指向一个代表对象的句柄或其他与此对象相关的位置和returnAddress类型（指向了一条字节码指令的地址）。
##### 本地方法栈（Native Method Stack）
本地方法栈与虚拟机栈发挥的作用类似，区别不过是虚拟机栈为虚拟机执行java方法（也就是说字节码）服务，而本地方法栈则为虚拟机使用到的
Native方法服务。
##### Java 堆
1. Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在虚拟机启动是创建。
存放对象实例
2. Java堆是垃圾收集器管理的主要区域，很多时候被称做“GC堆”（`Garbage Collected Heap`）

##### 方法区
方法区与java堆一样是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据。

##### 运行时常量池
运行时常量池（`Runtime Constant Pool`） 是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口、等描述信息外，还有一项信息是
常量池（`Constant Pool Table`） ，用于存放编译期生成的各种字面量和负号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

##### 对象的创建

1. 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存都放在另一边，中间防着一个指针作为分界点的指示器，那所分配内存
就仅仅是把那个指针向空闲空间挪动一段与对象大小相等的距离。这种分配方式称为：指针碰撞（`Bump the Pointer`）。
2. 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地记性指针碰撞了，虚拟机就必须维护一个列表，记录上那些内存块是可用的
，再分配的时候从列表中找到一块足够大的控件划分给对象实例，并更新列表上的记录，这种分配方式称为：空闲列表（`Free List`）。

##### 对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（`Header`）、实例数据（`Instance Data`） 和对齐填充（`Padding`）

##### 对象的访问定位
对象访问方式：使用句柄和直接指针两种

1. 使用句柄，java堆中将会划分出一块内存作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
2. 使用指针访问， reference中存储的直接就是对象地址。
3. 使用句柄优势：使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时但一定对象是非常普遍的行为）时只会改变句柄中
的实例数据指针，而reference本身不需要更改
4. 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销， HotSpot 使用直接指针访问方式。

##### Java堆溢出
java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，
那么在对象数量达到最大堆的容量限制后就会产生内存异常。
1. 内存泄漏 (Memory Leak)
2. 内存溢出（Memory Overflow） OOM OutOfMemoryError 内存溢出

##### 虚拟机栈和本地方法栈溢出

Java虚拟机规范中描述了两种异常

1. 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出`StackOverflowError`异常
2. 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常

在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常




