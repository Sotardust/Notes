
由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度
尽可能接近处理器运算速度的告诉缓存 （Cache）来作为内存与处理器之间的缓存。

内存模型：可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。

### 主内存与工作内存
Java内存模型规定了所有的变量都存储在主内存（Main
Memory）中（此处的主内存与介绍物理硬件时的内存名字一样，两者也可以互相类比：
，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working
Memory，可与前面讲的处理器高速缓存类比），
线程的工作内存保存了被该线程使用到的变量的内存副本拷贝，线程对变量的所有操作（读取，复制等）都必须在工作内存中进行
， 而不能直接读写主内存中的变量。


上面所说的主内存与工作内存，与Java内存区域中的Java堆、栈、方法区域等并不是同一层次的内存划分，这两者基本上是没有关系的


### 内存间交互操作
java内存模型中定义了8中操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分（对double和long类型的变量例外）
> lock(锁定)：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
> unlock（解锁）-> read（读）->load(载入) -> use(使用) -> assign(赋值) ->
> store (存储)-> write(写入)




### 对于Volatile型变量的特殊规则
1. 可见性：保证此变量对其他线程来说可以立即得知 
2. 禁止指令重排序优化

### 原子性、可见性与有序性
原子性：  
可见性：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改值。  
有序性：  

##### 先行发生原则

### Java与线程
线程是比进程更加轻量级的调度执行单元，线程的引入，可以把一个进程的资源分配和执行调度分开，
各个线程既可以共享进程资源（内存地址、文件I/O等），又个可以独立调度（线程是CPU调度的基本单位）。


实现线程主要3个方式：
1. 使用内核线程实现
2. 使用用户线程实现
3. 使用用户线程加轻量级进程混合实现

##### Java线程调度
线程调度是指系统为了线程分配处理器使用权的过程， 主要调度方式有两种：
1. 协同式线程调度（Cooperative
   Threads-Scheduling），线程的执行时间由线程本身控制，线程把自己的工作执行完了之后，要主动通知系统
   切换到另外一个线程上。
2. 抢占式线程调度（Preemptive
   Threads-Scheduling），每个线程将由系统来分配执行时间，线程的切换不由线程本身决定（java使用的就是此调度方式）

##### 状态转换
java语言定义了5中线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态。

1. 新建（New）：创建后尚未启动的线程处于这种状态
2. 运行（Runnable）
3. 无限期等待（Waiting）
4. 限期等待（Timed Waiting） 
5. 阻塞（Blocked）
6. 结束（Terminated）

### 线程安全与锁优化

##### 线程安全
如果一个对象可以安全的被多个线程同时使用，那它就是线程安全的。

线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，
或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象的线程是安全的。

线程安全的实现方法 ：
1. 互斥同步 




