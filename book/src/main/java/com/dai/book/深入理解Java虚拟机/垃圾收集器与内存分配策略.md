### 垃圾收集器 （Garbage Collection，GC）
1. 引用计数算法（Reference Counting），给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，
当引用失效时，计数器值就减1，任何时刻计数器为0的对象就是不可能被使用的。
2. 可达性分析算法（Reachability Analysis）

在Java语言中，可作为`GC Roots`的对象包括下面几种：
> 虚拟机栈（栈帧中的本地变量表）中引用的对象
> 方法区中类静态属性引用的对象
> 方法区中常量引用的对象
> 本地方法栈中JNI（一般指Native方法）引用的对象

java虚拟机里没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。

### 垃圾收集算法

##### 标记-清除算法（Mark - Sweep）
标记所有需要回收的对象，在标记完成后统一回收所有标记的对象。
标记和清除 效率不高，另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致
以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

##### 复制算法（Copying）
为了解决效率问题。
复制算法：它将可用内存按容量划分为大小相等的两块，每次只是使用其中的一块，当这块内存用完了，就将还存活着的对象复制到另外一块上面
，然后再把已使用过的内存空间一次清理掉。使用这种算法 回收新生代。

##### 标记-整理算法
标记整理算法：不是直接对可回收对象进行整理，而是让所有存货的对象都向一端移动，然后直接清理掉端边界以外的内存。

##### 分代收集算法（Generational Collection）
 新生代使用复制算法，老年代使用标记整理算法，永久代


### 垃圾收集器
新生代：Serial（单线程）， ParNew（serial多线程版本），Parallel Scavenge（有自适应调节策略，GCErgonomics）
老年代： CMS（Concurrent Mark Sweep） ，Serial Old（MSC）， Parallel Old
G1（Garbage First）
1. 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态
2. 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行与另一个CPU上。

##### CMS收集器

是一种以获取最短回收停顿时间为目标的收集器

##### Parallel Scavenge
目标则是达到一个可控制的吞吐量（Throughput），吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即：吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）


### 内存分配与回收策略
Java技术体系中所倡导的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。

##### 对象优先在Eden分配
大多数情况下 对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，

